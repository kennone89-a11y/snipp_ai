<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Kenai Recorder — SuperSafe v2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: dark;
      --bg: #050712;
      --bg2: #111320;
      --bg3: #191c2a;
      --accent: #2563eb;
      --accent-soft: rgba(37, 99, 235, 0.15);
      --danger: #ef4444;
      --text: #f9fafb;
      --muted: #9ca3af;
      --border: #272a3a;
      --radius: 18px;
      --shadow: 0 22px 45px rgba(0, 0, 0, 0.6);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top left, #111827 0, #020617 55%);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .shell {
      width: 100%;
      max-width: 720px;
      background: radial-gradient(circle at top left, #111827 0, #020617 55%);
      border-radius: 28px;
      padding: 28px 26px 26px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    h1 {
      margin: 0 0 4px;
      font-size: 1.45rem;
      letter-spacing: 0.03em;
    }
    .sub {
      margin: 0 0 16px;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .row {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px 12px;
      margin-bottom: 14px;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.8rem;
      padding: 3px 9px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: var(--muted);
    }
    .pill strong {
      color: var(--text);
      font-weight: 500;
    }
    label {
      font-size: 0.82rem;
      color: var(--muted);
    }
    input[type="number"] {
      width: 80px;
      padding: 4px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--bg3);
      color: var(--text);
      font-size: 0.85rem;
      outline: none;
    }
    input[type="number"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.4);
    }
    .btn {
      padding: 7px 15px;
      border-radius: 999px;
      border: none;
      font-size: 0.86rem;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: transform 0.08s ease-out, box-shadow 0.08s ease-out,
        background 0.15s ease-out;
    }
    .btn-primary {
      background: linear-gradient(135deg, #2563eb, #38bdf8);
      color: white;
      box-shadow: 0 14px 30px rgba(37, 99, 235, 0.55);
    }
    .btn-primary:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 8px 20px rgba(37, 99, 235, 0.45);
    }
    .btn-danger {
      background: rgba(248, 113, 113, 0.08);
      color: #fecaca;
      border: 1px solid rgba(248, 113, 113, 0.5);
    }
    .btn-danger:active {
      transform: translateY(1px) scale(0.99);
    }
    .btn-ghost {
      background: transparent;
      color: var(--muted);
      border: 1px solid var(--border);
    }
    .btn-ghost:active {
      transform: translateY(1px) scale(0.99);
    }
    audio {
      width: 100%;
      margin: 6px 0 2px;
    }
    #rec-timer {
      font-size: 0.8rem;
      color: var(--muted);
    }
    #status {
      margin-top: 12px;
      padding: 8px 10px;
      border-radius: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.78rem;
      white-space: pre-line;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--border);
      max-height: 140px;
      overflow: auto;
    }
    #status .ok {
      color: #bbf7d0;
    }
    #status .warn {
      color: #fde68a;
    }
    #status .err {
      color: #fecaca;
    }
    #ua {
      font-size: 0.7rem;
      color: var(--muted);
    }
    #uploadArea {
      margin-top: 16px;
      padding: 12px 12px 10px;
      border-radius: 16px;
      background: radial-gradient(circle at top left, #0f172a, #020617);
      border: 1px solid rgba(148, 163, 184, 0.4);
      display: none;
    }
    #publicUrl {
      margin-top: 4px;
      font-size: 0.8rem;
      word-break: break-all;
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--border);
    }
    .upload-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    @media (max-width: 640px) {
      .shell {
        padding: 20px 16px 18px;
        border-radius: 22px;
      }
      .row {
        flex-direction: column;
        align-items: flex-start;
      }
      .upload-row {
        flex-direction: column;
        align-items: stretch;
      }
      .btn {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <h1>Kenai Recorder — SuperSafe v2</h1>
    <p class="sub">
      WAV-only, 44.1 kHz mono, auto-stop, Supabase-upload med delbar länk.
    </p>

    <div class="row">
      <button id="btnStart" class="btn btn-primary">Starta inspelning</button>
      <button id="btnStop" class="btn btn-danger" disabled>Stoppa</button>
      <button id="btnDownload" class="btn btn-ghost" disabled>
        Ladda ner WAV
      </button>
    </div>

    <div class="row">
      <label
        >Auto-stop (sek):
        <input
          id="autoSeconds"
          type="number"
          min="10"
          max="600"
          step="10"
          value="120"
      /></label>
      <span class="pill">codec: <strong>wav @ 44.1k mono</strong></span>
      <span class="pill" id="ua"></span>
    </div>

    <audio id="player" controls></audio>
    <small
      id="rec-timer"
      style="display: block; margin-top: 4px; opacity: 0.85"
    >
      Inspelningstid: 00:00
    </small>

    <div id="status">Idle.</div>

    <div id="uploadArea">
      <div><strong>Uppladdad! Delbar länk:</strong></div>
      <div id="publicUrl"></div>
      <div class="upload-row">
        <button id="btnOpen" class="btn btn-primary" disabled>Öppna</button>
        <button id="btnCopy" class="btn btn-ghost" disabled>
          Kopiera länk
        </button>
      </div>
    </div>
  </div>

  <script>
    "use strict";

    // ====== SUPABASE – BYT BARA HÄR ======
    // Project URL, t.ex. https://abcxyz.supabase.co
    const SB_URL = 'https://hywwzzzxgagqhlxooekz.supabase.co'; 
    // Anon public key (EN rad)
    const SB_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh5d3d6enp4Z2FncWhseG9vZWt6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE5Mjk5NTcsImV4cCI6MjA3NzUwNTk1N30.A1BcczjSnP-LOh6p9XLozCBbBcr9LgHIcpjIqsk3eSA';

    const BUCKET = "audio";
    const BASE_PATH = "reviews";
    const MAKE_PUBLIC = true;

    // ====== UI refs ======
    const statusEl = document.getElementById("status");
    const playerEl = document.getElementById("player");
    const autoSecEl = document.getElementById("autoSeconds");
    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const btnDl = document.getElementById("btnDownload");
    const btnOpen = document.getElementById("btnOpen");
    const btnCopy = document.getElementById("btnCopy");
    const uploadArea = document.getElementById("uploadArea");
    const publicUrlEl = document.getElementById("publicUrl");
    const uaEl = document.getElementById("ua");
    const timerEl = document.getElementById("rec-timer");

    uaEl.textContent = navigator.userAgent;

    function log(msg, cls) {
      const line =
        (cls ? '<span class="' + cls + '">' + msg + "</span>" : msg) + "\n";
      statusEl.innerHTML = line + statusEl.innerHTML;
    }

    // ====== TIMER ======
    let recTimerId = null;
    let recStartedAt = 0;

    function formatTime(sec) {
      sec = Math.max(0, Math.floor(sec));
      const m = String(Math.floor(sec / 60)).padStart(2, "0");
      const s = String(sec % 60).padStart(2, "0");
      return `${m}:${s}`;
    }

    function startTimer() {
      recStartedAt = Date.now();
      if (recTimerId) {
        clearInterval(recTimerId);
        recTimerId = null;
      }
      timerEl.textContent = "Inspelningstid: 00:00";
      recTimerId = setInterval(() => {
        if (state !== "recording") {
          clearInterval(recTimerId);
          recTimerId = null;
          return;
        }
        const elapsedSec = (Date.now() - recStartedAt) / 1000;
        timerEl.textContent =
          "Inspelningstid: " + formatTime(elapsedSec || 0);
      }, 200);
    }

    function stopTimer() {
      if (recTimerId) {
        clearInterval(recTimerId);
        recTimerId = null;
      }
    }

    // ====== WAV encoder (44.1k mono, 16-bit) ======
    function floatTo16BitPCM(float32) {
      const len = float32.length;
      const buf = new Int16Array(len);
      for (let i = 0; i < len; i++) {
        let s = Math.max(-1, Math.min(1, float32[i]));
        buf[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
      }
      return buf;
    }

    function writeWavHeader(view, sampleRate, numSamples) {
      let offset = 0;
      const writeString = (s) => {
        for (let i = 0; i < s.length; i++) {
          view.setUint8(offset++, s.charCodeAt(i));
        }
      };

      const numChannels = 1;
      const bitsPerSample = 16;
      const blockAlign = (numChannels * bitsPerSample) / 8;
      const byteRate = sampleRate * blockAlign;
      const dataSize = numSamples * blockAlign;

      writeString("RIFF");
      view.setUint32(offset, 36 + dataSize, true);
      offset += 4;
      writeString("WAVE");
      writeString("fmt ");
      view.setUint32(offset, 16, true);
      offset += 4;
      view.setUint16(offset, 1, true);
      offset += 2;
      view.setUint16(offset, numChannels, true);
      offset += 2;
      view.setUint32(offset, sampleRate, true);
      offset += 4;
      view.setUint32(offset, byteRate, true);
      offset += 4;
      view.setUint16(offset, blockAlign, true);
      offset += 2;
      view.setUint16(offset, bitsPerSample, true);
      offset += 2;
      writeString("data");
      view.setUint32(offset, dataSize, true);
    }

    function encodeWav(chunks, sampleRate) {
      const length = chunks.reduce((acc, cur) => acc + cur.length, 0);
      const pcm = new Int16Array(length);
      let offset = 0;
      for (const chunk of chunks) {
        pcm.set(floatTo16BitPCM(chunk), offset);
        offset += chunk.length;
      }
      const buffer = new ArrayBuffer(44 + pcm.length * 2);
      const view = new DataView(buffer);
      writeWavHeader(view, sampleRate, pcm.length);
      let pos = 44;
      for (let i = 0; i < pcm.length; i++, pos += 2) {
        view.setInt16(pos, pcm[i], true);
      }
      return new Blob([view], { type: "audio/wav" });
    }

    // ====== Recorder ======
    let audioCtx = null;
    let mediaStream = null;
    let sourceNode = null;
    let scriptNode = null;
    let chunks = [];
    let sampleRate = 44100;
    let autoStopId = null;
    let state = "idle";
    let lastBlob = null;
    let lastPublicUrl = "";

    async function startRec() {
      if (state === "recording") return;
      try {
        const maxSeconds = Math.max(
          5,
          Math.min(600, parseInt(autoSecEl.value, 10) || 120)
        );

        chunks = [];
        lastBlob = null;
        lastPublicUrl = "";
        uploadArea.style.display = "none";
        publicUrlEl.textContent = "";
        btnDl.disabled = true;
        btnOpen.disabled = true;
        btnCopy.disabled = true;

        log("Ber om mikrofonåtkomst...", "warn");

        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: true,
          video: false,
        });

        audioCtx = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: 44100,
        });
        sampleRate = audioCtx.sampleRate;

        sourceNode = audioCtx.createMediaStreamSource(mediaStream);
        scriptNode = audioCtx.createScriptProcessor(4096, 1, 1);

        scriptNode.onaudioprocess = (e) => {
          if (state !== "recording") return;
          const input = e.inputBuffer.getChannelData(0);
          chunks.push(new Float32Array(input));
        };

        sourceNode.connect(scriptNode);
        scriptNode.connect(audioCtx.destination);

        state = "recording";
        btnStart.disabled = true;
        btnStop.disabled = false;

        log("Recording... auto-stop in " + maxSeconds + "s", "ok");
        startTimer();

        if (autoStopId) clearTimeout(autoStopId);
        autoStopId = setTimeout(() => {
          if (state === "recording") {
            log("Auto-stop nådd, stoppar inspelning...", "warn");
            stopRec();
          }
        }, maxSeconds * 1000);
      } catch (err) {
        console.error(err);
        log("Kunde inte starta inspelning: " + err.message, "err");
        cleanupAudio();
        state = "idle";
        btnStart.disabled = false;
        btnStop.disabled = true;
        stopTimer();
      }
    }

    function cleanupAudio() {
      if (autoStopId) {
        clearTimeout(autoStopId);
        autoStopId = null;
      }
      if (scriptNode) {
        scriptNode.disconnect();
        scriptNode.onaudioprocess = null;
        scriptNode = null;
      }
      if (sourceNode) {
        sourceNode.disconnect();
        sourceNode = null;
      }
      if (mediaStream) {
        mediaStream.getTracks().forEach((t) => t.stop());
        mediaStream = null;
      }
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
      }
    }

    async function stopRec() {
      if (state !== "recording") return;
      state = "stopping";
      btnStop.disabled = true;
      stopTimer();
      log("Stoppar inspelning och kodar WAV...", "warn");

      cleanupAudio();

      try {
        if (!chunks.length) {
          log("Inga ljuddata inspelade.", "err");
          state = "idle";
          btnStart.disabled = false;
          return;
        }
        const wavBlob = encodeWav(chunks, sampleRate);
        lastBlob = wavBlob;

        const url = URL.createObjectURL(wavBlob);
        playerEl.src = url;
        btnDl.disabled = false;

        const sizeMb = (wavBlob.size / (1024 * 1024)).toFixed(2);
        log(
          "Done: " +
            new Date().toISOString() +
            " wav ≈ " +
            sizeMb +
            " MB @ " +
            sampleRate +
            " Hz",
          "ok"
        );

        state = "done";
        btnStart.disabled = false;

        // direkt upload
        uploadArea.style.display = "block";
        log("Laddar upp till Supabase...", "warn");
        const publicUrl = await uploadToSupabase(wavBlob);
        if (publicUrl) {
          lastPublicUrl = publicUrl;
          publicUrlEl.textContent = publicUrl;
          btnOpen.disabled = false;
          btnCopy.disabled = false;
          log("Upload OK ✅", "ok");
        } else {
          log("Upload misslyckades.", "err");
        }
      } catch (err) {
        console.error(err);
        log("Fel vid stopp/kodning: " + err.message, "err");
        state = "idle";
        btnStart.disabled = false;
      }
    }
    // ====== Supabase upload ======
    async function uploadToSupabase(blob) {
      try {
        const ts = Date.now();
        const filename = `kenai-${ts}.wav`;
        const objectPath = `${BASE_PATH}/${filename}`;

        // Upload-URL: bucket + path (ingen "public/" här)
        const uploadUrl = `${SB_URL}/storage/v1/object/${BUCKET}/${objectPath}`;

        const res = await fetch(uploadUrl, {
          method: "POST",
          headers: {
            "Content-Type": "audio/wav",
            "x-upsert": "true",
            apikey: SB_ANON,
            Authorization: "Bearer " + SB_ANON,
          },
          body: blob,
        });

        if (!res.ok) {
          const text = await res.text().catch(() => "");
          log("Upload fel: " + res.status + " " + res.statusText, "err");
          if (text) log(text, "err");
          return "";
        }

        // Publik URL – här används "public/" för läsning
        const publicUrl = `${SB_URL}/storage/v1/object/public/${BUCKET}/${objectPath}`;
        return publicUrl;
      } catch (err) {
        log("Upload exception: " + err.message, "err");
        return "";
      }
    }

    // ====== Buttons ======
    btnStart.addEventListener("click", () => {
      startRec();
    });

    btnStop.addEventListener("click", () => {
      stopRec();
    });

    btnDl.addEventListener("click", () => {
      if (!lastBlob) return;
      const url = URL.createObjectURL(lastBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "kenai-" + Date.now() + ".wav";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    });

    btnOpen.addEventListener("click", () => {
      if (!lastPublicUrl) return;
      window.open(lastPublicUrl, "_blank");
    });

    btnCopy.addEventListener("click", async () => {
      if (!lastPublicUrl) return;
      try {
        await navigator.clipboard.writeText(lastPublicUrl);
        log("Länk kopierad till urklipp.", "ok");
      } catch (err) {
        log("Kunde inte kopiera länk: " + err.message, "err");
      }
    });

    log("Idle.");
  </script>
</body>
</html>
