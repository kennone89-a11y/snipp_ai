<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>snipp_ai</title>
  <style>
    body{margin:0;padding:24px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#0b0f14;color:#e9eef5}
    .wrap{max-width:920px;margin:0 auto}
    h1{font-size:24px;margin:0 0 16px}
    .card{background:#101722;border:1px solid #223246;border-radius:12px;padding:16px;margin-top:16px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .btn{padding:10px 14px;border-radius:10px;border:1px solid #223246;background:#0f1520;color:#e9eef5;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btnStart{background:#0d6efd;border-color:#0b5ed7}
    .btnStop{background:#dc3545;border-color:#bb2d3b}
    .muted{color:#98a6b5}
  </style>

  <!-- DÖDA evt service workers + caches (en gång) -->
  <script>
    (async()=>{try{
      const regs = await navigator.serviceWorker?.getRegistrations?.();
      regs?.forEach(r=>r.unregister());
      if (window.caches?.keys) {
        const ks = await caches.keys();
        await Promise.all(ks.map(k=>caches.delete(k)));
      }
    }catch(e){}})();
  </script>

  <!-- Supabase CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <div class="wrap">
    <h1>snipp_ai</h1>

    <div class="card">
      <h3 style="margin-top:0">Inspelning</h3>
      <div class="row" style="margin-top:8px">
        <button id="recordBtn" class="btn btnStart" onclick="startRec()">Starta inspelning</button>
        <button id="stopBtn"  class="btn btnStop"  onclick="stopRec()" disabled>Stoppa</button>
      </div>
      <small id="codec" class="muted" style="display:block;margin-top:8px"></small>
    </div>
  </div>

  <!-- ALL JS I SAMMA FIL (ingen extern app.js) -->
  <script>
  'use strict';

  // ---- Enhetsdetektion utan regex-magi ----
  const ua = (navigator.userAgent || '').toLowerCase();
  const isIOS = ua.includes('iphone') || ua.includes('ipad') || ua.includes('ipod')
             || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  const isSafari = ua.includes('safari') && !ua.includes('chrome') && !ua.includes('android');

  // === FYLL I DINA SUPABASE-VÄRDEN (exakt 2 rader) ===
  const SUPABASE_URL  = 'https://hywwzzzxgagqhlxooekz.supabase.co;    // <-- BYT
  const SUPABASE_ANON = 'sb_publishable_fLQC4d675JKhsc-QXj2oGw_BGIfI87Z';                       // <-- BYT

  // Init Supabase
  const sb = (window.supabase && SUPABASE_URL && SUPABASE_ANON)
    ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON)
    : null;
  window.sb = sb;

  // Globala
  let mediaRecorder = null;
  let recStream = null;
  let chunks = [];
  let currentFmt = { mime: '', ext: '', contentType: '' };

  function pickAudioFormat(){
    const safariFirst = [
      'audio/mp4;codecs=mp4a.40.2',
      'audio/mp4',
      'audio/webm;codecs=opus',
      'audio/webm'
    ];
    const webmFirst = [
      'audio/webm;codecs=opus',
      'audio/webm',
      'audio/mp4;codecs=mp4a.40.2',
      'audio/mp4'
    ];
    const prefs = isSafari ? safariFirst : webmFirst;

    if (window.MediaRecorder && MediaRecorder.isTypeSupported) {
      for (const m of prefs) {
        if (MediaRecorder.isTypeSupported(m)) {
          if (m.startsWith('audio/webm')) return { mime: m, ext: 'webm', contentType: 'audio/webm' };
          if (m.startsWith('audio/mp4'))  return { mime: m, ext: 'm4a',  contentType: 'audio/mp4'  };
        }
      }
    }
    return { mime: 'wav-fallback', ext: 'wav', contentType: 'audio/wav' };
  }

  async function startRec(){
    try {
      if (!sb) { alert('Supabase saknas – ladda om sidan.'); return; }

      currentFmt = pickAudioFormat();

      const audioConstraints = isIOS
        ? { echoCancellation: true, noiseSuppression: true }
        : { echoCancellation: true, noiseSuppression: true, channelCount: 1, sampleRate: 48000 };

      recStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });

      const codecEl = document.getElementById('codec');
      if (codecEl) codecEl.textContent = `Codec: ${currentFmt.mime} | iOS:${isIOS} Safari:${isSafari}`;

      chunks = [];

      if (currentFmt.mime !== 'wav-fallback' && window.MediaRecorder) {
        let ok = true;
        try { mediaRecorder = new MediaRecorder(recStream, { mimeType: currentFmt.mime }); }
        catch { ok = false; }

        if (ok) {
          mediaRecorder.ondataavailable = (e)=>{ if (e.data && e.data.size>0) chunks.push(e.data); };
          mediaRecorder.onerror = (e)=> alert('MediaRecorder error: ' + (e?.name || e));
          mediaRecorder.onstop = ()=>{ try{ recStream?.getTracks()?.forEach(t=>t.stop()); }catch{} };
          mediaRecorder.start(isIOS ? 500 : 1000);
        } else {
          currentFmt = { mime: 'wav-fallback', ext: 'wav', contentType: 'audio/wav' };
          await wavFallbackStart(recStream);
        }
      } else {
        await wavFallbackStart(recStream);
      }

      document.getElementById('recordBtn')?.setAttribute('disabled','true');
      document.getElementById('stopBtn')?.removeAttribute('disabled');

    } catch (err) {
      console.error(err);
      alert('Kunde inte starta inspelning. Kolla mikrofon-behörighet.');
    }
  }

  async function stopRec(){
    try {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        await new Promise(res=>{
          mediaRecorder.onstop = ()=>{ try{ recStream?.getTracks()?.forEach(t=>t.stop()); }catch{}; res(); };
          mediaRecorder.stop();
        });
      } else {
        await wavFallbackStop();
        try { recStream?.getTracks()?.forEach(t=>t.stop()); } catch {}
      }

      const blob = (currentFmt.mime === 'wav-fallback')
        ? wavFallbackGetBlob()
        : new Blob(chunks, { type: currentFmt.contentType });

      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      const filename = `review-${ts}.${currentFmt.ext}`;

      await uploadToSupabase(blob, filename, currentFmt.contentType);

      document.getElementById('recordBtn')?.removeAttribute('disabled');
      document.getElementById('stopBtn')?.setAttribute('disabled','true');
      chunks = [];
      alert('Uppladdad ✅');
    } catch (err) {
      console.error(err);
      alert('Kunde inte stoppa/lagra inspelningen.');
    }
  }

  async function uploadToSupabase(blob, filename, contentType){
    const path = `audio/reviews/${filename}`;
    const { error } = await sb.storage.from('audio').upload(path, blob, { upsert:true, contentType });
    if (error) throw error;
  }

  // ---- WAV fallback (WebAudio) ----
  let wavCtx=null, wavSource=null, wavProcessor=null;
  let wavBuffers=[];
  let wavSampleRate=48000;

  async function wavFallbackStart(stream){
    const Ctx = window.AudioContext || window.webkitAudioContext;
    wavCtx = new Ctx({ sampleRate: wavSampleRate });
    wavSource = wavCtx.createMediaStreamSource(stream);
    wavProcessor = wavCtx.createScriptProcessor(4096, 1, 1);
    wavBuffers = [];
    wavProcessor.onaudioprocess = (e)=>{
      const input = e.inputBuffer.getChannelData(0);
      wavBuffers.push(new Float32Array(input));
    };
    wavSource.connect(wavProcessor);
    wavProcessor.connect(wavCtx.destination);
  }
  async function wavFallbackStop(){
    if (!wavCtx) return;
    try{ wavProcessor.disconnect(); wavSource.disconnect(); }catch{}
    await wavCtx.close();
  }
  function wavFallbackGetBlob(){
    const length = wavBuffers.reduce((a,c)=>a+c.length,0);
    const pcm = new Float32Array(length);
    let off=0; for (const b of wavBuffers){ pcm.set(b, off); off+=b.length; }
    const buf = encodeWAV(pcm, wavSampleRate);
    return new Blob([buf], { type:'audio/wav' });
  }
  function encodeWAV(samples, sampleRate){
    const bytesPerSample=2, blockAlign=1*bytesPerSample;
    const buffer = new ArrayBuffer(44 + samples.length*bytesPerSample);
    const view = new DataView(buffer);
    writeString(view,0,'RIFF');
    view.setUint32(4,36+samples.length*bytesPerSample,true);
    writeString(view,8,'WAVE');
    writeString(view,12,'fmt ');
    view.setUint32(16,16,true);
    view.setUint16(20,1,true);
    view.setUint16(22,1,true);
    view.setUint32(24,sampleRate,true);
    view.setUint32(28,sampleRate*blockAlign,true);
    view.setUint16(32,blockAlign,true);
    view.setUint16(34,16,true);
    writeString(view,36,'data');
    view.setUint32(40,samples.length*bytesPerSample,true);
    floatTo16BitPCM(view,44,samples);
    return view;
  }
  function floatTo16BitPCM(view, offset, input){
    for (let i=0;i<input.length;i++,offset+=2){
      const s = Math.max(-1, Math.min(1, input[i]));
      view.setInt16(offset, s<0 ? s*0x8000 : s*0x7FFF, true);
    }
  }
  function writeString(view, offset, str){
    for (let i=0;i<str.length;i++) view.setUint8(offset+i, str.charCodeAt(i));
  }

  // Exponera globalt till knapparna
  window.startRec = startRec;
  window.stopRec  = stopRec;
  </script>
</body>
</html>
