<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>snipp_ai — sanity</title>
  <style>
    body{margin:0;padding:24px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#0b0f14;color:#e9eef5}
    .wrap{max-width:920px;margin:0 auto}
    .row{display:flex;gap:8px}
    .btn{padding:10px 14px;border-radius:10px;border:1px solid #223246;background:#0f1520;color:#e9eef5;cursor:pointer}
  </style>

  <!-- döda ev service worker cache -->
  <script>
    (async()=>{try{
      const regs = await navigator.serviceWorker?.getRegistrations?.();
      regs?.forEach(r=>r.unregister());
      if (window.caches?.keys) {
        const ks = await caches.keys();
        await Promise.all(ks.map(k=>caches.delete(k)));
      }
    }catch(_){}})();
  </script>

  <!-- (behövs först i steg 2, men gör inget om den laddas redan nu) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <div class="wrap">
    <h1>snipp_ai — sanity</h1>
    <div class="row" style="margin-top:8px">
      <button id="recordBtn" class="btn" onclick="startRec()">Starta inspelning</button>
      <button id="stopBtn"   class="btn" onclick="stopRec()">Stoppa</button>
    </div>
    <small id="codec" style="display:block;margin-top:8px;color:#98a6b5"></small>
  </div>

  <!-- ny, ren fil -->
  <script>
'use strict';
<script>
'use strict';

// enkel UA<script>
'use strict';

// UA-detekt
const ua = (navigator.userAgent || '').toLowerCase();
const isIOS = ua.includes('iphone') || ua.includes('ipad') || ua.includes('ipod')
           || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
const isSafari = ua.includes('safari') && !ua.includes('chrome') && !ua.includes('android');

// ===== Fyll i dessa två =====
const SUPABASE_URL  = 'https://hywwzzzxgagqhlxooekz.supabase.co;
// BYT
const SUPABASE_ANON = 'sb_publishable_fLQC4d675JKhsc-QXj2oGw_BGIfI87Z';                       // BYT
// ============================

// Ladda supabase-js om den inte finns
(async () => {
  if (!window.supabase) {
    await new Promise(resolve => {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
      s.onload = resolve;
      document.head.appendChild(s);
    });
  }
})();

// Initiera klient
let sb = null;
(async () => {
  while (!window.supabase) await new Promise(r=>setTimeout(r,10));
  sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
  window.sb = sb;
})();

// Globala inspelningsprylar
let mediaRecorder = null;
let recStream = null;
let chunks = [];
let currentFmt = { mime: '', ext: '', contentType: '' };

// Välj format
function pickAudioFormat() {
  const safariFirst = [
    'audio/mp4;codecs=mp4a.40.2',
    'audio/mp4',
    'audio/webm;codecs=opus',
    'audio/webm'
  ];
  const webmFirst = [
    'audio/webm;codecs=opus',
    'audio/webm',
    'audio/mp4;codecs=mp4a.40.2',
    'audio/mp4'
  ];
  const prefs = isSafari ? safariFirst : webmFirst;
  if (window.MediaRecorder && MediaRecorder.isTypeSupported) {
    for (const m of prefs) {
      if (MediaRecorder.isTypeSupported(m)) {
        if (m.startsWith('audio/webm')) return { mime: m, ext: 'webm', contentType: 'audio/webm' };
        if (m.startsWith('audio/mp4'))  return { mime: m, ext: 'm4a',  contentType: 'audio/mp4'  };
      }
    }
  }
  return { mime: 'wav-fallback', ext: 'wav', contentType: 'audio/wav' };
}

// Start
async function startRec(){
  try{
    if (!sb) { alert('Initierar... prova igen'); return; }

    currentFmt = pickAudioFormat();
    const audioConstraints = isIOS
      ? { echoCancellation: true, noiseSuppression: true }
      : { echoCancellation: true, noiseSuppression: true, channelCount: 1, sampleRate: 48000 };

    recStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });

    const codecEl = document.getElementById('codec');
    if (codecEl) codecEl.textContent = 'Codec: ' + currentFmt.mime + '  iOS:' + isIOS + '  Safari:' + isSafari;

    chunks = [];

    if (currentFmt.mime !== 'wav-fallback' && window.MediaRecorder) {
      let ok = true;
      try { mediaRecorder = new MediaRecorder(recStream, { mimeType: currentFmt.mime }); } catch { ok = false; }
      if (ok) {
        mediaRecorder.ondataavailable = (e)=>{ if (e.data && e.data.size>0) chunks.push(e.data); };
        mediaRecorder.onerror = (e)=> alert('MediaRecorder error: ' + (e?.name || e));
        mediaRecorder.onstop = ()=>{ try{ recStream?.getTracks()?.forEach(t=>t.stop()); }catch{} };
        mediaRecorder.start(isIOS ? 500 : 1000);
      } else {
        currentFmt = { mime: 'wav-fallback', ext: 'wav', contentType: 'audio/wav' };
        await wavFallbackStart(recStream);
      }
    } else {
      await wavFallbackStart(recStream);
    }

    document.getElementById('recordBtn')?.setAttribute('disabled','true');
    document.getElementById('stopBtn')?.removeAttribute('disabled');
  }catch(err){
    console.error(err);
    alert('Kunde inte starta inspelning. Kolla mic-tillstånd.');
  }
}

// Stop
async function stopRec(){
  try{
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      await new Promise(res=>{
        mediaRecorder.onstop = ()=>{ try{ recStream?.getTracks()?.forEach(t=>t.stop()); }catch{}; res(); };
        mediaRecorder.stop();
      });
    } else {
      await wavFallbackStop();
      try { recStream?.getTracks()?.forEach(t=>t.stop()); } catch {}
    }

    const blob = (currentFmt.mime === 'wav-fallback')
      ? wavFallbackGetBlob()
      : new Blob(chunks, { type: currentFmt.contentType });

    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    const filename = `review-${ts}.${currentFmt.ext}`;

    await uploadToSupabase(blob, filename, currentFmt.contentType);

    document.getElementById('recordBtn')?.removeAttribute('disabled');
    document.getElementById('stopBtn')?.setAttribute('disabled','true');
    chunks = [];
    alert('Uppladdad ✅');
  }catch(err){
    console.error(err);
    alert('Kunde inte stoppa/lagra inspelningen.');
  }
}

// Uppladdning
async function uploadToSupabase(blob, filename, contentType){
  const path = `audio/reviews/${filename}`;
  const { error } = await sb.storage.from('audio').upload(path, blob, { upsert:true, contentType });
  if (error) throw error;
}

// WAV-fallback
let wavCtx=null, wavSource=null, wavProcessor=null;
let wavBuffers=[];
let wavSampleRate=48000;

async function wavFallbackStart(stream){
  const Ctx = window.AudioContext || window.webkitAudioContext;
  wavCtx = new Ctx({ sampleRate: wavSampleRate });
  wavSource = wavCtx.createMediaStreamSource(stream);
  wavProcessor = wavCtx.createScriptProcessor(4096, 1, 1);
  wavBuffers = [];
  wavProcessor.onaudioprocess = (e)=>{
    const input = e.inputBuffer.getChannelData(0);
    wavBuffers.push(new Float32Array(input));
  };
  wavSource.connect(wavProcessor);
  wavProcessor.connect(wavCtx.destination);
}
async function wavFallbackStop(){
  if (!wavCtx) return;
  try{ wavProcessor.disconnect(); wavSource.disconnect(); }catch{}
  await wavCtx.close();
}
function wavFallbackGetBlob(){
  const length = wavBuffers.reduce((a,c)=>a+c.length,0);
  const pcm = new Float32Array(length);
  let off=0; for (const b of wavBuffers){ pcm.set(b, off); off+=b.length; }
  const buf = encodeWAV(pcm, wavSampleRate);
  return new Blob([buf], { type:'audio/wav' });
}
function encodeWAV(samples, sampleRate){
  const bytesPerSample=2, blockAlign=1*bytesPerSample;
  const buffer = new ArrayBuffer(44 + samples.length*bytesPerSample);
  const view = new DataView(buffer);
  writeString(view,0,'RIFF');
  view.setUint32(4,36+samples.length*bytesPerSample,true);
  writeString(view,8,'WAVE');
  writeString(view,12,'fmt ');
  view.setUint32(16,16,true);
  view.setUint16(20,1,true);
  view.setUint16(22,1,true);
  view.setUint32(24,sampleRate,true);
  view.setUint32(28,sampleRate*blockAlign,true);
  view.setUint16(32,blockAlign,true);
  view.setUint16(34,16,true);
  writeString(view,36,'data');
  view.setUint32(40,samples.length*bytesPerSample,true);
  floatTo16BitPCM(view,44,samples);
  return view;
}
function floatTo16BitPCM(view, offset, input){
  for (let i=0;i<input.length;i++,offset+=2){
    const s = Math.max(-1, Math.min(1, input[i]));
    view.setInt16(offset, s<0 ? s*0x8000 : s*0x7FFF, true);
  }
}
function writeString(view, offset, str){
  for (let i=0;i<str.length;i++) view.setUint8(offset+i, str.charCodeAt(i));
}

// Exponera till knapparna
window.startRec = startRec;
window.stopRec  = stopRec;
</script>

</script> 
</body>
</html>
