<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kenai Recorder – DIAG v1</title>
<style>
  body{margin:0;background:#0b0f14;color:#e6eef7;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto}
  .wrap{max-width:720px;margin:32px auto;padding:20px}
  .card{background:#111723;border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:16px}
  h1{margin:0 0 8px}
  button{appearance:none;border:0;border-radius:12px;padding:12px 16px;font-weight:700;cursor:pointer;background:#29bf12;color:#000}
  #status{display:block;white-space:pre-wrap;background:#0a0e14;border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:10px;margin-top:12px;min-height:80px}
  audio{width:100%;margin-top:12px}
  .muted{color:#8aa0b6}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Kenai Recorder – DIAG v1</h1>
    <p class="muted">Tryck “Start 5s test”. Den spelar in 5 sek, bygger WAV och spelar upp. Allt loggas nedan.</p>
    <button id="btn">▶︎ Start 5s test</button>
    <small id="status">Klar.</small>
    <audio id="player" controls></audio>
  </div>
</div>

<script>
(function(){
  'use strict';
  const btn = document.getElementById('btn');
  const statusEl = document.getElementById('status');
  const player = document.getElementById('player');

  function log(x){ statusEl.textContent += (statusEl.textContent ? '\n' : '') + x; }

  btn.onclick = startTest;

  async function startTest(){
    statusEl.textContent = '';
    try{
      log('1) Begär mikrofon…');
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      log('✔︎ Mikrofon OK');

      const AC = window.AudioContext || window.webkitAudioContext;
      const ctx = new AC({ sampleRate: 44100 });
      log('2) AudioContext @ ' + ctx.sampleRate + ' Hz');

      const src = ctx.createMediaStreamSource(stream);
      const channels = 1; // mono
      const proc = ctx.createScriptProcessor(4096, channels, channels);
      const buffers = [ [] ];
      proc.onaudioprocess = e => {
        buffers[0].push(new Float32Array(e.inputBuffer.getChannelData(0)));
      };
      src.connect(proc); proc.connect(ctx.destination);
      log('3) Spelar in i 5 sek…');
      btn.disabled = true;

      await waitMs(5000);

      log('4) Stoppar inspelning…');
      try{ proc.disconnect(); src.disconnect(); }catch{}
      try{ stream.getTracks().forEach(t=>t.stop()); }catch{}

      // Packa WAV
      log('5) Bygger WAV…');
      const rate = ctx.sampleRate;
      const inter = concatMono(buffers[0]);
      const wav = encodeWav(inter, rate, 1);
      const blob = new Blob([wav], { type: 'audio/wav' });
      log('✔︎ WAV klar: ' + (blob.size/1024/1024).toFixed(2) + ' MB');

      // Stäng ctx efter att blob är klar
      try{ await ctx.close(); }catch{}

      const url = URL.createObjectURL(blob);
      player.src = url;
      try{ player.load(); }catch{}
      log('6) Försöker spela upp… (tryck play om den inte autostartar)');
      try{ await player.play(); log('✔︎ Spelas'); }catch(e){ log('ℹ︎ Autoplay blockerat, tryck play'); }

    }catch(err){
      log('✖︎ FEL: ' + err.message);
    }finally{
      btn.disabled = false;
    }
  }

  function waitMs(n){ return new Promise(res=>setTimeout(res,n)); }

  function concatMono(chunks){
    let len = 0;
    for(let i=0;i<chunks.length;i++) len += chunks[i].length;
    const out = new Float32Array(len);
    let off = 0;
    for(let i=0;i<chunks.length;i++){ out.set(chunks[i], off); off += chunks[i].length; }
    return out;
  }

  function encodeWav(samples, sampleRate, numChannels){
    const bytesPerSample = 2;
    const blockAlign = numChannels * bytesPerSample;
    const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    const view = new DataView(buffer);

    writeStr(view, 0, 'RIFF');
    view.setUint32(4, 36 + samples.length * bytesPerSample, true);
    writeStr(view, 8, 'WAVE');
    writeStr(view, 12, 'fmt ');
    view.setUint32(16, 16, true);      // Subchunk1Size
    view.setUint16(20, 1, true);       // PCM
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true);      // bits per sample
    writeStr(view, 36, 'data');
    view.setUint32(40, samples.length * bytesPerSample, true);

    // PCM16
    let idx = 44;
    for(let i=0;i<samples.length;i++){
      let s = Math.max(-1, Math.min(1, samples[i]));
      view.setInt16(idx, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      idx += 2;
    }
    return view;
  }

  function writeStr(view, off, str){ for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); }
})();
</script>
</body>
</html>
