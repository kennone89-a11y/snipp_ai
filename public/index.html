<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kenai – Universal Audio Recorder (Gold Build)</title>
  <style>
    :root { --bg:#0b0f14; --card:#111723; --muted:#8aa0b6; --text:#e6eef7; --acc:#4cc9f0; --ok:#29bf12; --warn:#ffbe0b; --err:#ff006e; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial}
    .wrap{max-width:860px;margin:32px auto;padding:20px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.06);border-radius:18px;padding:18px 18px 14px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    h1{margin:0 0 8px;font-size:24px}
    p.muted{color:var(--muted);margin:4px 0 16px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{appearance:none;border:0;border-radius:14px;padding:12px 16px;font-weight:600;cursor:pointer}
    #startBtn{background:var(--ok);color:#000}
    #stopBtn{background:var(--err)}
    #stopBtn[disabled]{opacity:.4;cursor:not-allowed}
    #startBtn[disabled]{opacity:.4;cursor:not-allowed}
    small#status{display:block;margin-top:10px;color:var(--muted);white-space:pre-wrap}
    .kv{display:grid;grid-template-columns:140px 1fr;gap:6px 12px;margin:10px 0 4px}
    .kv b{color:#9ec3ff;font-weight:600}
    .bar{height:2px;background:linear-gradient(90deg,var(--acc),transparent);opacity:.35;margin:8px 0 12px}
    canvas{width:100%;height:96px;background:#0a0e14;border-radius:12px;border:1px solid rgba(255,255,255,.06)}
    audio{width:100%;margin-top:12px}
    a.download{display:inline-block;margin-top:10px;color:#fff;text-decoration:none;border:1px solid rgba(255,255,255,.2);padding:8px 12px;border-radius:12px}
    code.badge{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;background:#0a0e14;border:1px solid rgba(255,255,255,.09);padding:2px 8px;border-radius:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Kenai – Universal Recorder <span class="bar"></span></h1>
      <p class="muted">Automatisk codec-detektion (WebM/Opus → Chrome/Edge/Firefox, M4A (audio/mp4) → Safari), och säker WAV‑fallback på alla enheter. En tydlig state‑maskin & statusrad hjälper felsökning.</p>

      <div class="row">
        <button id="startBtn">▶︎ Starta inspelning</button>
        <button id="stopBtn" disabled>■ Stoppa</button>
        <span id="dot" style="margin-left:8px">● idle</span>
      </div>

      <div class="kv" id="kv">
        <b>Tillstånd:</b><span id="state">idle</span>
        <b>Codec:</b><span id="codec">–</span>
        <b>MIME:</b><span id="mime">–</span>
        <b>Filnamn:</b><span id="fname">–</span>
        <b>Storlek:</b><span id="fsize">–</span>
        <b>Varaktighet:</b><span id="dur">00:00</span>
        <b>UA:</b><span id="ua"></span>
      </div>

      <small id="status">Klar. Tryck Starta för att begära mikrofonåtkomst.</small>

      <canvas id="scope" width="1024" height="192"></canvas>

      <audio id="player" controls></audio>
      <a id="dl" class="download" download style="display:none">⬇︎ Ladda ner</a>
    </div>
  </div>

<script>
(function(){
  'use strict';

  // ---------- Elements ----------
  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const stateEl  = document.getElementById('state');
  const codecEl  = document.getElementById('codec');
  const mimeEl   = document.getElementById('mime');
  const fnameEl  = document.getElementById('fname');
  const fsizeEl  = document.getElementById('fsize');
  const durEl    = document.getElementById('dur');
  const statusEl = document.getElementById('status');
  const uaEl     = document.getElementById('ua');
  const player   = document.getElementById('player');
  const dl       = document.getElementById('dl');
  const dot      = document.getElementById('dot');

  uaEl.textContent = navigator.userAgent;

  // ---------- State machine ----------
  const STATE = { IDLE:'idle', REC:'recording', STOPPING:'stopping', DONE:'done' };
  let state = STATE.IDLE;
  let startedAt = 0;
  let ticker = null;

  function setState(s){
    state = s;
    stateEl.textContent = s;
    dot.textContent = (s===STATE.REC? '● recording' : s===STATE.STOPPING? '● stopping' : s===STATE.DONE? '● done' : '● idle');
    dot.style.color = (s===STATE.REC? '#ff3864' : s===STATE.STOPPING? '#ffbe0b' : s===STATE.DONE? '#29bf12' : '#8aa0b6');
    startBtn.disabled = (s===STATE.REC || s===STATE.STOPPING);
    stopBtn.disabled  = !(s===STATE.REC);
  }

  function timeStr(ms){
    const sec = Math.floor(ms/1000);
    const m = String(Math.floor(sec/60)).padStart(2,'0');
    const s = String(sec%60).padStart(2,'0');
    return `${m}:${s}`;
  }

  function startTicker(){
    startedAt = performance.now();
    stopTicker();
    ticker = setInterval(()=>{
      durEl.textContent = timeStr(performance.now()-startedAt);
    }, 250);
  }
  function stopTicker(){ if(ticker){ clearInterval(ticker); ticker=null; } }

  function log(msg){ statusEl.textContent = msg; }

  // ---------- Waveform ----------
  const scope = document.getElementById('scope');
  const g = scope.getContext('2d');
  function drawWave(analyser){
    const N = analyser.fftSize;
    const buf = new Uint8Array(N);
    function frame(){
      if(state===STATE.REC){
        analyser.getByteTimeDomainData(buf);
        g.clearRect(0,0,scope.width,scope.height);
        g.beginPath();
        const mid = scope.height/2;
        for(let x=0; x<scope.width; x++){
          const i = Math.floor(x/ scope.width * N);
          const v = (buf[i]-128)/128;
          const y = mid + v * (scope.height/2-6);
          if(x===0) g.moveTo(x,y); else g.lineTo(x,y);
        }
        g.strokeStyle = '#4cc9f0';
        g.lineWidth = 2;
        g.stroke();
      }
      if(state===STATE.REC) requestAnimationFrame(frame); else g.clearRect(0,0,scope.width,scope.height);
    }
    requestAnimationFrame(frame);
  }

  // ---------- Recording backends ----------
  let mediaStream = null;
  let mediaRecorder = null;
  let chunks = [];
  let chosenMime = '';
  let chosenExt  = '';

  // WAV fallback buffers
  let wavCtx = null, wavProc = null, wavSource = null, wavBuffers = [], wavChannels = 1, wavSampleRate = 48000;

  function pickMime(){
    const candidates = [
      'audio/webm;codecs=opus',      // Chrome/Edge/Firefox desktop & Android
      'audio/mp4',                   // Safari iOS/macOS (M4A)
      'audio/ogg;codecs=opus',       // Firefox
    ];
    for(const m of candidates){
      try{ if(window.MediaRecorder && MediaRecorder.isTypeSupported(m)) return m; }catch{ /* ignore */ }
    }
    return '';
  }

  async function startMediaRecorder(){
    chosenMime = pickMime();
    chosenExt  = chosenMime.includes('webm')? 'webm' : chosenMime.includes('mp4')? 'm4a' : chosenMime.includes('ogg')? 'ogg' : '';

    if(!window.MediaRecorder || !chosenMime){
      log('MediaRecorder saknas eller inget MIME stöds → byter till WAV‑fallback.');
      return false;
    }

    try{
      mediaRecorder = new MediaRecorder(mediaStream, { mimeType: chosenMime, audioBitsPerSecond: 128000 });
    }catch(err){
      log('Kunde inte starta MediaRecorder: '+err.message+' → WAV‑fallback.');
      return false;
    }

    chunks = [];
    mediaRecorder.ondataavailable = e => { if(e.data && e.data.size>0) chunks.push(e.data); };
    mediaRecorder.onstop = finalizeMediaRecorder;
    mediaRecorder.onerror = e => { log('MediaRecorder fel: '+e.error?.message || e.name); };

    mediaRecorder.start(1000); // timeslice för att spola ut data
    return true;
  }

  function finalizeMediaRecorder(){
    try{
      const blob = new Blob(chunks, { type: chosenMime });
      finish(blob, chosenExt || 'bin');
    }catch(err){
      log('Kunde inte bygga blob från MediaRecorder, använder WAV‑fallback.');
      startWavFallback();
    }
  }

  function startWavFallback(){
    // Web Audio ScriptProcessor fallback
    const AC = window.AudioContext || window.webkitAudioContext;
    wavCtx = new AC({ sampleRate: 48000 });
    wavSampleRate = wavCtx.sampleRate;
    wavSource = wavCtx.createMediaStreamSource(mediaStream);
    wavChannels = Math.min(2, wavSource.channelCount || 1); // ofta 1 på iPhone
    wavProc = wavCtx.createScriptProcessor(4096, wavChannels, wavChannels);

    wavBuffers = Array.from({length:wavChannels}, ()=>[]);

    wavProc.onaudioprocess = e => {
      for(let ch=0; ch<wavChannels; ch++){
        const data = e.inputBuffer.getChannelData(ch);
        wavBuffers[ch].push(new Float32Array(data));
      }
    };

    // Visa vågform via analyser
    const analyser = wavCtx.createAnalyser();
    analyser.fftSize = 2048;
    wavSource.connect(analyser);
    drawWave(analyser);

    wavSource.connect(wavProc);
    wavProc.connect(wavCtx.destination);

    chosenMime = 'audio/wav';
    chosenExt  = 'wav';
    log('WAV‑fallback aktiv. Spelar in via Web Audio.');
  }

  function stopWavFallback(){
    if(!wavCtx) return;
    try{ wavProc && wavProc.disconnect(); }catch{}
    try{ wavSource && wavSource.disconnect(); }catch{}
    try{ wavCtx && wavCtx.close(); }catch{}

    // Packa WAV
    const len = wavBuffers[0].reduce((a,b)=>a+b.length,0);
    const interleaved = new Float32Array(len * wavChannels);
    let offset = 0;
    const chCount = wavChannels;
    // interleave
    for(let i=0;i<wavBuffers[0].length;i++){
      const frameLen = wavBuffers[0][i].length;
      for(let s=0;s<frameLen;s++){
        for(let ch=0; ch<chCount; ch++){
          const sample = wavBuffers[ch][i][s];
          interleaved[(offset+s)*chCount + ch] = sample;
        }
      }
      offset += frameLen;
    }
    // encode PCM16 WAV
    const bytesPerSample = 2;
    const blockAlign = chCount * bytesPerSample;
    const buffer = new ArrayBuffer(44 + interleaved.length * bytesPerSample);
    const view = new DataView(buffer);

    // RIFF header
    writeStr(view, 0, 'RIFF');
    view.setUint32(4, 36 + interleaved.length * bytesPerSample, true);
    writeStr(view, 8, 'WAVE');
    writeStr(view, 12, 'fmt ');
    view.setUint32(16, 16, true);                 // PCM chunk size
    view.setUint16(20, 1, true);                  // PCM format
    view.setUint16(22, chCount, true);            // channels
    view.setUint32(24, wavSampleRate, true);      // sample rate
    view.setUint32(28, wavSampleRate * blockAlign, true); // byte rate
    view.setUint16(32, blockAlign, true);         // block align
    view.setUint16(34, 16, true);                 // bits per sample
    writeStr(view, 36, 'data');
    view.setUint32(40, interleaved.length * bytesPerSample, true);

    // PCM samples
    let idx = 44;
    for(let i=0;i<interleaved.length;i++){
      const s = Math.max(-1, Math.min(1, interleaved[i]));
      view.setInt16(idx, s<0 ? s*0x8000 : s*0x7FFF, true);
      idx += 2;
    }

    const blob = new Blob([view], { type: 'audio/wav' });
    finish(blob, 'wav');

    // helpers
    function writeStr(v, o, s){ for(let i=0;i<s.length;i++) v.setUint8(o+i, s.charCodeAt(i)); }
  }

  // ---------- Orchestration ----------
  async function startRec(){
    try{
      setState(STATE.REC);
      log('Begär mikrofonåtkomst…');
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      startTicker();

      // setup analyser for MediaRecorder path as well
      const AC = window.AudioContext || window.webkitAudioContext;
      const ctx = new AC();
      const src = ctx.createMediaStreamSource(mediaStream);
      const analyser = ctx.createAnalyser();
      analyser.fftSize = 2048; src.connect(analyser); drawWave(analyser);

      const ok = await startMediaRecorder();
      if(!ok){
        // MediaRecorder unavailable → WAV fallback
        startWavFallback();
      }

      codecEl.textContent = ok ? 'MediaRecorder' : 'WAV-fallback';
      mimeEl.textContent  = chosenMime || '–';
      fnameEl.textContent = '–';
      fsizeEl.textContent = '–';
      dl.style.display = 'none'; dl.removeAttribute('href');
      player.src = '';

    }catch(err){
      setState(STATE.IDLE);
      stopTicker();
      log('Mikrofon nekad eller fel: '+err.message);
    }
  }

  async function stopRec(){
    if(state!==STATE.REC) return;
    setState(STATE.STOPPING);
    stopTicker();

    try{
      if(mediaRecorder && mediaRecorder.state !== 'inactive'){
        mediaRecorder.stop();
      }else{
        stopWavFallback();
      }
    }catch{ /* ignore */ }

    // Stäng stream spår
    try{ mediaStream?.getTracks().forEach(t=>t.stop()); }catch{}
  }

  function finish(blob, ext){
    setState(STATE.DONE);
    const url = URL.createObjectURL(blob);
    player.src = url;

    const name = `kenai-${ts()}.${ext}`;
    dl.download = name; dl.href = url; dl.style.display='inline-block';
    fnameEl.textContent = name;
    fsizeEl.textContent = human(blob.size);
    mimeEl.textContent  = blob.type || mimeEl.textContent;
    codecEl.textContent = codecEl.textContent || (ext==='wav'?'WAV-fallback':'MediaRecorder');
    log('Klar. Spela upp eller ladda ner filen.');
  }

  function ts(){
    const d = new Date();
    const Y=d.getFullYear(), M=String(d.getMonth()+1).padStart(2,'0'), D=String(d.getDate()).padStart(2,'0');
    const h=String(d.getHours()).padStart(2,'0'), m=String(d.getMinutes()).padStart(2,'0'), s=String(d.getSeconds()).padStart(2,'0');
    return `${Y}${M}${D}-${h}${m}${s}`;
  }

  function human(n){
    if(n<1024) return n+' B';
    if(n<1024*1024) return (n/1024).toFixed(1)+' KB';
    return (n/1024/1024).toFixed(2)+' MB';
  }

  // ---------- Buttons & iOS resume ----------
  startBtn.addEventListener('click', ()=>{
    startRec();
  });
  stopBtn.addEventListener('click', ()=>{
    stopRec();
  });

  // Touch to resume AudioContext on iOS if needed
  window.addEventListener('touchstart', ()=>{
    try{
      const AC = window.AudioContext || window.webkitAudioContext;
      const ctx = new AC();
      if(ctx.state === 'suspended') ctx.resume();
      setTimeout(()=>ctx.close(), 500);
    }catch{}
  }, { once:true });

})();
</script>
</body>
</html>
